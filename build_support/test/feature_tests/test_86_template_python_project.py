"""Feature tests for selective test execution based on git changes.

These tests verify that the build system only runs tests for subprojects
that have been modified since the last commit, rather than running the
full test suite every time. Each test creates a mock lightweight project,
optionally modifies specific files, and runs ``make test`` inside a
nested Docker container to verify the expected subproject tests ran.

Inner Docker Image Notes:
    The tests reuse the pre-built ``template_python_project:dev`` and
    ``template_python_project:build`` Docker images (skipping rebuild
    via ``--ci-cd-feature-test-mode``). The mock project is
    volume-mounted at ``/usr/dev`` inside the container, so the inner
    ``make test`` sees the mock project's files through ``PYTHONPATH``.

    Because the Docker images are built from the real project but run
    against the mock project, any source files generated by the test
    must satisfy the full build pipeline (ruff lint, mypy type checks,
    style enforcement including Google-style docstrings with typed
    ``Args`` and ``Returns`` sections, and module-level docstrings).

    Stale ``__pycache__`` bytecode from a prior run can cause the
    inner Docker process to execute an outdated version of test or
    source files. If a test fails with content that does not match
    the current source, clearing ``__pycache__`` directories in the
    project tree is a reliable first troubleshooting step.

    Logs from the inner ``make test`` invocations are saved to
    ``test_scratch_folder/test_logs/<test_name>.log`` and are
    invaluable for diagnosing failures in the nested build pipeline.
"""

from datetime import timedelta
from pathlib import Path

import pytest
from _pytest.fixtures import SubRequest
from feature_tests.conftest import (  # type: ignore[import-untyped]
    run_command_and_save_logs,
)

from build_support.ci_cd_tasks.validation_tasks import (
    SubprojectFeatureTests,
    SubprojectUnitTests,
)
from build_support.ci_cd_vars.build_paths import get_build_runtime_report_path
from build_support.ci_cd_vars.project_setting_vars import get_project_name
from build_support.ci_cd_vars.project_structure import (
    get_dockerfile,
    get_poetry_lock_file,
)
from build_support.ci_cd_vars.subproject_structure import (
    PythonSubproject,
    SubprojectContext,
    get_python_subproject,
)
from build_support.dag_engine import BuildRunReport


@pytest.mark.usefixtures("mock_lightweight_project_with_unit_tests_and_feature_tests")
def test_do_not_run_tests_for_unmodified_projects(
    request: SubRequest,
    mock_project_root: Path,
    make_command_prefix: list[str],
    real_project_root_dir: Path,
) -> None:
    """Verify that unmodified subprojects have their tests skipped.

    When no files have changed since the baseline commit, all
    subproject test tasks should complete near-instantly (under 0.1s),
    indicating they were effectively skipped.
    """
    run_command_and_save_logs(
        args=[*make_command_prefix, "test"],
        cwd=mock_project_root,
        test_name=request.node.name,
        real_project_root_dir=real_project_root_dir,
    )
    expected_report_yaml = get_build_runtime_report_path(project_root=mock_project_root)
    runtime_report = BuildRunReport.from_yaml(expected_report_yaml.read_text())

    assert all(
        task.duration < timedelta(seconds=0.1)
        for task in runtime_report.report
        if task.task_name.startswith(SubprojectFeatureTests.__class__.__name__)
        or task.task_name.startswith(SubprojectUnitTests.__class__.__name__)
    )


@pytest.mark.usefixtures("mock_lightweight_project_with_unit_tests_and_feature_tests")
def test_run_tests_for_single_modified_subproject(
    request: SubRequest,
    mock_project_root: Path,
    make_command_prefix: list[str],
    real_project_root_dir: Path,
) -> None:
    """Verify that only the modified subproject's tests are executed.

    Adds a new source file and unit test to the PYPI subproject,
    then runs ``make test``. The generated source and test files
    must include module-level docstrings and Google-style function
    docstrings (with typed ``Args`` and ``Returns``) to pass the
    inner Docker build pipeline's ruff and style-enforcement checks.

    Asserts that PYPI test tasks took meaningful time (>0.9s) while
    all other subproject test tasks completed near-instantly (<0.1s).
    """
    subproject = get_python_subproject(
        subproject_context=SubprojectContext.PYPI, project_root=mock_project_root
    )
    subproject_pkg_dir = subproject.get_python_package_dir()
    subproject_src_file = subproject_pkg_dir.joinpath("src_file.py")
    subproject_src_file.write_text(
        '''"""A simple Python module for testing purposes."""

from time import sleep


def add_slow(a: int, b: int) -> int:
    """Adds two numbers slowly.

    Args:
        a (int): The first number.
        b (int): The second number.

    Returns:
        int: The sum of the two numbers.
    """
    sleep(0.5)
    return a + b


def subtract_slow(a: int, b: int) -> int:
    """Subtracts two numbers slowly.

    Args:
        a (int): The first number.
        b (int): The second number.

    Returns:
        int: The difference of the two numbers.
    """
    sleep(0.5)
    return a - b
'''
    )
    project_unit_test_dir = subproject.get_test_suite_dir(
        test_suite=PythonSubproject.TestSuite.UNIT_TESTS
    )
    project_unit_test_file = project_unit_test_dir.joinpath("test_src_file.py")
    project_name = get_project_name(project_root=mock_project_root)
    project_unit_test_file.write_text(
        f'''from {project_name}.src_file import add_slow, subtract_slow


def test_add_slow() -> None:
    """Adds two numbers slowly.

    Args:
        a (int): The first number.
        b (int): The second number.

    Returns:
        int: The sum of the two numbers.
    """
    a = 2
    b = 3
    expected_sum = 5
    assert add_slow(a=a, b=b) == expected_sum


def test_subtract_slow() -> None:
    """Subtracts two numbers slowly.

    Args:
        a (int): The first number.
        b (int): The second number.

    Returns:
        int: The difference of the two numbers.
    """
    a = 2
    b = 3
    expected_diff = -1
    assert subtract_slow(a=a, b=b) == expected_diff

'''
    )
    run_command_and_save_logs(
        args=[*make_command_prefix, "test"],
        cwd=mock_project_root,
        test_name=request.node.name,
        real_project_root_dir=real_project_root_dir,
    )
    expected_report_yaml = get_build_runtime_report_path(project_root=mock_project_root)
    runtime_report = BuildRunReport.from_yaml(expected_report_yaml.read_text())

    assert all(
        task.duration < timedelta(seconds=0.1)
        for task in runtime_report.report
        if (
            task.task_name.startswith(SubprojectFeatureTests.__class__.__name__)
            or task.task_name.startswith(SubprojectUnitTests.__class__.__name__)
        )
        and not task.task_name.endswith(SubprojectContext.PYPI.name)
    )
    assert all(
        task.duration > timedelta(seconds=0.9)
        for task in runtime_report.report
        if (
            task.task_name.startswith(SubprojectFeatureTests.__class__.__name__)
            or task.task_name.startswith(SubprojectUnitTests.__class__.__name__)
        )
        and task.task_name.endswith(SubprojectContext.PYPI.name)
    )


@pytest.mark.usefixtures("mock_lightweight_project_with_unit_tests_and_feature_tests")
def test_run_all_tests_if_dockerfile_modified(
    request: SubRequest,
    mock_project_root: Path,
    make_command_prefix: list[str],
    real_project_root_dir: Path,
) -> None:
    """Verify all tests run when the Dockerfile is modified.

    Appending a newline to the Dockerfile should cause the build
    system to treat every subproject as affected and run all tests.
    """
    dockerfile = get_dockerfile(project_root=mock_project_root)
    dockerfile_contents = dockerfile.read_text()
    dockerfile.write_text(dockerfile_contents + "\n")
    run_command_and_save_logs(
        args=[*make_command_prefix, "test"],
        cwd=mock_project_root,
        test_name=request.node.name,
        real_project_root_dir=real_project_root_dir,
    )
    expected_report_yaml = get_build_runtime_report_path(project_root=mock_project_root)
    runtime_report = BuildRunReport.from_yaml(expected_report_yaml.read_text())

    assert all(
        task.duration > timedelta(seconds=0.9)
        for task in runtime_report.report
        if task.task_name.startswith(SubprojectFeatureTests.__class__.__name__)
        or task.task_name.startswith(SubprojectUnitTests.__class__.__name__)
    )


@pytest.mark.usefixtures("mock_lightweight_project_with_unit_tests_and_feature_tests")
def test_run_all_tests_if_poetry_lock_modified(
    request: SubRequest,
    mock_project_root: Path,
    make_command_prefix: list[str],
    real_project_root_dir: Path,
) -> None:
    """Verify all tests run when poetry.lock is modified.

    Appending a newline to ``poetry.lock`` should cause the build
    system to treat every subproject as affected and run all tests.
    """
    poetry_lock_file = get_poetry_lock_file(project_root=mock_project_root)
    poetry_lock_file_contents = poetry_lock_file.read_text()
    poetry_lock_file.write_text(poetry_lock_file_contents + "\n")
    run_command_and_save_logs(
        args=[*make_command_prefix, "test"],
        cwd=mock_project_root,
        test_name=request.node.name,
        real_project_root_dir=real_project_root_dir,
    )
    expected_report_yaml = get_build_runtime_report_path(project_root=mock_project_root)
    runtime_report = BuildRunReport.from_yaml(expected_report_yaml.read_text())

    assert all(
        task.duration > timedelta(seconds=0.9)
        for task in runtime_report.report
        if task.task_name.startswith(SubprojectFeatureTests.__class__.__name__)
        or task.task_name.startswith(SubprojectUnitTests.__class__.__name__)
    )
